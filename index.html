
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Treeset Data Structure</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="treeset"
                  title="Treeset Data Structure"
                  environment="web"
                  feedback-link="https://github.com/Jean-Dv/codelabs-treeset/blob/master/markdown/treeset">
    
      <google-codelab-step label="Método 
add(O object)" duration="1">
        <h2 is-upgraded>Paso a paso</h2>
<p>El método <code>add</code> se utiliza para agregar un elemento al conjunto o colección. Aquí explicaremos cómo funciona visualmente paso a paso:</p>
<h3 is-upgraded>Paso 1: Inserción del primer elemento</h3>
<p>Supongamos que tenemos un TreeSet vacío y queremos agregar el elemento &#34;C&#34;. En este caso, el árbol se vería así:</p>
<p class="image-container"><img alt="Tree with C" src="img/7d0df9f7b86468ea.png"></p>
<h3 is-upgraded>Paso 2: Inserción del segundo elemento</h3>
<p>Ahora, si queremos agregar el elemento &#34;A&#34;, se compara con el elemento existente (&#34;C&#34;) y se decide que &#34;A&#34; es menor, por lo que se coloca a la izquierda:</p>
<p class="image-container"><img alt="Tree C and A" src="img/20c221d0e78f824a.png"></p>
<h3 is-upgraded>Paso 3: Inserción del tercer elemento</h3>
<p>Añadimos el elemento &#34;B&#34;, que es mayor que &#34;A&#34; pero menor que &#34;C&#34;, por lo que se coloca a la derecha de &#34;A&#34; y a la izquierda de &#34;C&#34;:</p>
<p class="image-container"><img alt="Tree C, A, B" src="img/b3c4bd3272585927.png"></p>
<h2 is-upgraded>Complejidad temporal:</h2>
<p>La complejidad temporal de <code>add</code> en un TreeSet es O(log N), donde N es el número de elementos en el conjunto. Debido a la estructura del árbol de busqueda binaria, las inserciones se realizan eficientemente.</p>
<h2 is-upgraded>Ejemplo de código:</h2>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos usando el método add
        treeSet.add(&#34;C&#34;);
        treeSet.add(&#34;A&#34;);
        treeSet.add(&#34;B&#34;);

        // Mostrar el TreeSet
        System.out.println(&#34;TreeSet: &#34; + treeSet);
    }
}
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<p>El método <code>add</code> mantiene la propiedad de orden en el TreeSet, asegurando que los elementos se ubiquen correctamente en el árbol.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
addAll(Collection&lt;? extends E&gt; c)" duration="1">
        <h2 is-upgraded>Paso a paso</h2>
<h3 is-upgraded>Paso 1: Creación de TreeSet y Collection</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;
import java.util.ArrayList;
import java.util.Collection;

public class TreeSetExample {
    public static void main(String[] args) {
        TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();
        treeSet.add(&#34;A&#34;);
        treeSet.add(&#34;B&#34;);
        treeSet.add(&#34;C&#34;);
        Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Agregar elementos a la colección</h3>
<pre><code language="language-java" class="language-java">collection.add(&#34;D&#34;);
collection.add(&#34;E&#34;);
collection.add(&#34;F&#34;);
</code></pre>
<h3 is-upgraded>Paso 3: Uso del método <code>addAll</code></h3>
<pre><code language="language-java" class="language-java">treeSet.addAll(collection);
</code></pre>
<h2 is-upgraded>Funcionamiento en un árbol de busqueda binaria</h2>
<p>Antes de ejecutar el método <code>addAll</code>, el árbol se ve así:</p>
<p class="image-container"><img alt="Tree C, A, B" src="img/b3c4bd3272585927.png"></p>
<p>Después de ejecutar el método <code>addAll</code>, el árbol se ve así:</p>
<p class="image-container"><img alt="Tree C, A, B" src="img/dbcd5bd4cb7dcccb.png"></p>
<h2 is-upgraded>Complejidad temporal:</h2>
<p>La complejidad temporal de addAll en un TreeSet depende de la cantidad de elementos en la colección a agregar. Si la colección tiene N elementos, la complejidad sería O(N * log N).</p>
<h2 is-upgraded>Conclusión:</h2>
<p>El método addAll permite agregar todos los elementos de una colección al TreeSet, manteniendo la propiedad de orden en el árbol de búsqueda binaria.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
ceiling(E e)" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
        treeSet.add(3);
        treeSet.add(6);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>ceiling(E e)</code></h3>
<pre><code language="language-java" class="language-java"> // Obtener el elemento igual o mayor al elemento especificado
Integer ceilingElement = treeSet.ceiling(4);

// Imprimir el elemento obtenido (o null si no hay elemento mayor o igual)
System.out.println(&#34;Elemento igual o mayor a 4: &#34; + ceilingElement);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>ceiling(e)</code> devuelve el elemento igual o mayor al elemento especificado (e). En este caso, dado que hemos agregado los números 5, 2, 8, 3 y 6, el elemento igual o mayor a 4 es 5.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">Elemento igual o mayor a 4: 5
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<p>El método <code>ceiling(e)</code> es útil para encontrar el primer elemento igual o mayor al valor especificado en el conjunto.</p>
<h2 is-upgraded>Nota adicional:</h2>
<ul>
<li>Si no hay un elemento igual o mayor al especificado, el método devuelve null.</li>
<li>Este método puede ser especialmente útil cuando se necesita encontrar el siguiente elemento más grande o igual en un conjunto ordenado.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
clear()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h2 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h2>
<pre><code language="language-java" class="language-java">import java.io.*;
import java.util.TreeSet;

public class TreeSetDemo {
    public static void main(String args[])
    {
        // Creating an empty TreeSet
        TreeSet&lt;String&gt; tree = new TreeSet&lt;String&gt;();

        // Use add() method to add elements into the Set
        tree.add(&#34;Welcome&#34;);
        tree.add(&#34;To&#34;);
        tree.add(&#34;Geeks&#34;);
        tree.add(&#34;4&#34;);
        tree.add(&#34;Geeks&#34;);
        tree.add(&#34;TreeSet&#34;);

        // Displaying the TreeSet
        System.out.println(&#34;TreeSet: &#34; + tree);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>clear()</code></h3>
<pre><code language="language-java" class="language-java">	 // Clearing the TreeSet using clear() method
        tree.clear();

        // Displaying the final tree
        System.out.println(&#34;After clearing TreeSet: &#34; + tree);
    }
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>se utiliza para eliminar todos los elementos de un TreeSet. El uso del método clear() solo borra todo el elemento del conjunto y no elimina el conjunto.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">TreeSet: [4, Geeks, To, TreeSet, Welcome]
After clearing TreeSet: []
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>El propósito principal es proporcionar una forma conveniente de vaciar completamente el conjunto, eliminando todos los elementos existentes.</li>
<li>Este método es útil cuando se desea restablecer o reiniciar el conjunto, y su invocación resultará en un conjunto vacío.</li>
</ul>
<h2 is-upgraded>Funcionamiento en un árbol de busqueda binaria</h2>
<p>Arbol normal sin aplicar el metodo <img alt="TreeSet without clear" src="img/9e28b3fc8e644143.png"></p>
<p>Arbol depues del metodo clear() <img alt="TreeSet with clear" src="img/d62dfd6f46d620d3.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
clone()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h2 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h2>
<pre><code language="language-java" class="language-java">import java.io.*;
import java.util.TreeSet;

public class TreeSetDemo {
    public static void main(String args[]) {
        // Creating an empty TreeSet
        TreeSet&lt;String&gt; tree = new TreeSet&lt;String&gt;();

        // Use add() method to add elements into the Set
        tree.add(&#34;Welcome&#34;);
        tree.add(&#34;To&#34;);
        tree.add(&#34;Geeks&#34;);
        tree.add(&#34;4&#34;);
        tree.add(&#34;Geeks&#34;);
        tree.add(&#34;TreeSet&#34;);

        // Displaying the TreeSet
        System.out.println(&#34;TreeSet: &#34; + tree);
   }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>clone()</code></h3>
<pre><code language="language-java" class="language-java">	 // Creating a new cloned set
        TreeSet cloned_set = new TreeSet();

        // Cloning the set using clone() method
        cloned_set = (TreeSet)tree.clone();
    }
</code></pre>
<h2 is-upgraded>Paso 3:imprimir en la consola el contenido del TreeSet clonado</h2>
<p>// Displaying the cloned_set System.out.println(&#34;The cloned TreeSet: &#34; + cloned_set);</p>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>Se utiliza para devolver una copia superficial del conjunto de árboles mencionado. Simplemente crea una copia del conjunto.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">TreeSet: [4, Geeks, To, TreeSet, Welcome]
The cloned TreeSet: [4, Geeks, To, TreeSet, Welcome]
</code></pre>
<p>Devuelve clon de la lista ingresada</p>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>Se crea un nuevo ‘TreeSet&#39;, pero los elementos dentro de este nuevo conjunto son los mismos objetos que los del conjunto original.No se clonan los elementos en sí.</li>
</ul>
<h2 is-upgraded>Nota adicional:</h2>
<ul>
<li>Dado que no se clonan los elementos, si se modifican los elementos en el conjunto clonado, esos cambios también se reflejarán en el conjunto original y viceversa.</li>
</ul>
<h2 is-upgraded>Funcionamiento en un árbol de busqueda binaria</h2>
<p>(img/clone.png) <img alt="TreeSet clone" src="img/45ad9a5e0f96a5c7.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
comparator()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación de TreeSet con comparador personalizado</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;
import java.util.Comparator;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet con comparador personalizado (orden inverso)
        TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;(Comparator.reverseOrder());

        // Agregar elementos al TreeSet
        treeSet.add(&#34;C&#34;);
        treeSet.add(&#34;A&#34;);
        treeSet.add(&#34;B&#34;);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>comparator</code></h3>
<pre><code language="language-java" class="language-java">Comparator&lt;String&gt; comparator = treeSet.comparator();
System.out.println(&#34;Comparador: &#34; + comparator);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>En este ejemplo, el comparador utilizado es <code>Comparator.reverseOrder()</code>, lo que significa que los elementos se ordenarán en orden inverso al orden natural.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">Comparador: java.util.Collections$ReverseComparator@hashcode
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>Si se utiliza un comparador personalizado, el método <code>comparator</code> devolverá ese comparador</li>
<li>Si no se proporciona un comparador al crear el <code>TreeSet</code>, el método <code>comparator</code> devolvera <code>null</code>, indicando que se está utilizando el orden natural de los elementos.</li>
</ul>
<h2 is-upgraded>Nota adicional:</h2>
<p>Si el conjunto se creó utilizando el orden natural de los elementos, <code>comparator</code> devolverá <code>null</code>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
contains(Object o)" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h2 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h2>
<pre><code language="language-java" class="language-java">import java.io.*;
import java.util.TreeSet;

public class TreeSetDemo {
    // Importing required classes
import java.io.*;
import java.util.TreeSet;

// Main class
public class GFG {

    // Main driver method
    public static void main(String args[])
    {

        // Creating an empty TreeSet of string type
        TreeSet&lt;String&gt; tree = new TreeSet&lt;String&gt;();

        // Adding elements in TreeSet
        // Using add() method to
        tree.add(&#34;Welcome&#34;);
        tree.add(&#34;To&#34;);
        tree.add(&#34;Geeks&#34;);
        tree.add(&#34;4&#34;);
        tree.add(&#34;Geeks&#34;);
        tree.add(&#34;TreeSet&#34;);

        // Displaying the TreeSet
        System.out.println(&#34;TreeSet: &#34; + tree);
   }
}
</code></pre>
<h3 is-upgraded>Paso 2: Compruebe si hay un elemento específico en el TreeSet anterior</h3>
<pre><code>         usando el método contains() de la clase TreeSet
</code></pre>
<pre><code>// Printing a boolean value
        System.out.println(
            &#34;Does the Set contains &#39;TreeSet&#39;? &#34;
            + tree.contains(&#34;TreeSet&#34;));
    }
}
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>se utiliza para comprobar si un elemento específico está presente en el TreeSet o no. Así que, básicamente, se utiliza para comprobar si un TreeSet contiene algún elemento en particular.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">TreeSet: [4, Geeks, To, TreeSet, Welcome]
Does the Set contains &#39;TreeSet&#39;? true
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>La principal función del método ‘contains&#39; en un ‘TreeSet&#39; es verificar si un elemento específico está presente en el conjunto. El método devuelve ‘true&#39; si el elemento está presente y ‘false&#39; en caso contrario.</li>
</ul>
<h2 is-upgraded>Funcionamiento en un árbol de busqueda binaria</h2>
<ol type="1">
<li>Comienza en la raíz &#34;Welcome&#34;.</li>
<li>Comparación: &#34;treeset&#34; se compara con &#34;Welcome&#34;. Dado que &#34;treeset&#34; es mayor lexicográficamente, la búsqueda se dirige hacia la derecha.</li>
<li>Ahora estamos en el nodo &#34;To&#34;.</li>
<li>Comparación: &#34;treeset&#34; se compara con &#34;To&#34;. Dado que &#34;treeset&#34; es mayor lexicográficamente, la búsqueda se dirige hacia la derecha.</li>
<li>Ahora estamos en el nodo &#34;TreeSet&#34;.</li>
<li>Comparación: &#34;treeset&#34; se compara con &#34;TreeSet&#34;. Dado que son iguales, se ha encontrado &#34;treeset&#34;.</li>
</ol>
<p>Arbol Normal <img alt="TreeSet contains" src="img/d928633da623c4fe.png"> Dspues de aplicar el metodo contains() <img alt="TreeSet contains" src="img/3d366dc300995e1.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
descendingIterator?()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h2 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h2>
<pre><code language="language-java" class="language-java">import java.util.*;

public class GFG1 {
    public static void main(String[] argv) throws Exception
    {
        try {

            // create tree set object
            TreeSet&lt;Integer&gt; treeadd = new TreeSet&lt;Integer&gt;();

            // populate the TreeSet using add() method
            treeadd.add(10);
            treeadd.add(20);
            treeadd.add(30);
            treeadd.add(40);

            // Print the TreeSet
            System.out.println(&#34;TreeSet: &#34; + treeadd);
   }
}
</code></pre>
<h3 is-upgraded>Paso 2: Creación el Iterador Descendente usando el metodo descendingIterator()</h3>
<pre><code language="language-java" class="language-java">// Printing a boolean value
     Iterator&lt;Integer&gt;iterator = treeadd.descendingIterator();
    }
}
</code></pre>
<h2 is-upgraded>paso 3: Impresión de los Valores Utilizando el Iterador Descendente</h2>
<pre><code language="language-java" class="language-java">System.out.println(&#34;\nValues using DescendingIterator:&#34;);
while (iterator.hasNext()) {
    System.out.println(&#34;Value : &#34; + iterator.next());
}
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>se utiliza para devolver un iterador sobre los elementos de este conjunto en orden descendente.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">TreeSet: [10, 20, 30, 40]

Values using DescendingIterator:
Value : 40
Value : 30
Value : 20
Value : 10
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>Este método es útil cuando se necesita recorrer los elementos en dirección opuesta al orden natural del conjunto.</li>
</ul>
<h2 is-upgraded>Funcionamiento en un árbol de busqueda binaria</h2>
<p>Arbol antes de aplicar el metodo desendinfIterator() <img alt="TreeSet descendingIterator" src="img/c7808de73258f4bc.png"> Despues de aplicar el metodo desendingIterator() <img alt="TreeSet descendingIterator" src="img/4019f465ec715df.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
descendingSet()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h2 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h2>
<pre><code language="language-java" class="language-java">import java.util.*;

public class GFG1 {
    public static void main(String[] argv)
        throws Exception
    {
        try {

            // create tree set object
            TreeSet&lt;String&gt; treeadd = new TreeSet&lt;String&gt;();

            // populate the TreeSet using add() method
            treeadd.add(&#34;A&#34;);
            treeadd.add(&#34;B&#34;);
            treeadd.add(&#34;C&#34;);
            treeadd.add(&#34;D&#34;);

            // Print the TreeSet
            System.out.println(&#34;TreeSet: &#34; + treeadd);
</code></pre>
<h3 is-upgraded>Paso 2: Creación el Iterador Descendente usando el metodo descendingSet()</h3>
<pre><code language="language-java" class="language-java"> NavigableSet&lt;String&gt;treereverse = treeadd.descendingSet();

 // getting iterated view of NavigableSet
 Iterator&lt;String&gt; iterator = treereverse.iterator();

</code></pre>
<h2 is-upgraded>paso 3: Impresión de los Valores</h2>
<pre><code language="language-java" class="language-java">System.out.println(&#34;\nValues using DescendingSet:&#34;);

            // printing the integrated value
            while (iterator.hasNext()) {
                System.out.println(&#34;Value : &#34;
                                   + iterator.next());
            }
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>se utiliza para devolver una vista en orden inverso de los elementos contenidos en este conjunto. El conjunto descendente está respaldado por este conjunto, por lo que los cambios en el conjunto se reflejan en el conjunto descendente y viceversa</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">TreeSet: [A, B, C, D]

Values using DescendingSet:
Value : D
Value : C
Value : B
Value : A
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<p>-Devuelve una vista reversa del conjunto original, ordenada en orden descendente. Es importante destacar que descendingSet no crea un nuevo conjunto, sino que proporciona una vista inversa del conjunto existente. Cualquier cambio en el conjunto original se reflejará en la vista descendente y viceversa.</p>
<h2 is-upgraded>Funcionamiento en un árbol de busqueda binaria</h2>
<p>Arbol antes de aplicar el metodo desendingSet() <img alt="TreeSet descendingIterator" src="img/e3d65bc3109cdbe1.png"> Despues de aplicar el metodo desendingSet() <img alt="TreeSet with clear" src="img/91cbf60900d95e9d.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
first()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreesetExample {
    public static void main(String[] args) {
        // Crea a un TreeSet
        TreeSet&lt;Integer&gt; tree = new TreeSet&lt;Integer&gt;();

        // Agrega elementos
        tree.add(14);
        tree.add(8);
        tree.add(200);
        tree.add(48);
        tree.add(7);
        tree.add(124);
    }
}

</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>first</code></h3>
<pre><code language="language-java" class="language-java"> // Mostrando el elemento más bajo del Treeset
    System.out.println(&#34;El primer elemento es: &#34; + tree.first());
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método devuelve el elemento más bajo en el Treeset. Si los elementos son de tipo cadena, se verifican en orden alfabético y si los elementos son de tipo entero, se devuelve el número entero más pequeño, en este caso el 7</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">El primer elemento es: 7
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>El método first() es útil para obtener el primer elemento del conjunto.</li>
<li>A diferencia de <code>pollFirst()</code>, <code>first()</code> no elimina el elemento del conjunto.</li>
</ul>
<h2 is-upgraded>Nota adicional:</h2>
<p>El método <code>first()</code> en un TreeSet proporciona una manera eficiente de acceder al primer elemento del conjunto sin realizar ninguna modificación en la estructura del conjunto, permitiendo operaciones de solo lectura de manera eficiente.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
floor?(E e)" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(10);
        treeSet.add(5);
        treeSet.add(15);
        treeSet.add(7);
        treeSet.add(12);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>floor?(E e)</code></h3>
<pre><code language="language-java" class="language-java">// Obtener el elemento igual o menor al elemento especificado
Integer floorElement = treeSet.floor(9);

// Imprimir el elemento obtenido (o null si no hay elemento menor o igual)
System.out.println(&#34;Elemento igual o menor a 9: &#34; + floorElement);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>floor?(E e)</code> devuelve el elemento igual o menor al elemento especificado (e). En este caso, dado que hemos agregado los números 10, 5, 15, 7 y 12, el elemento igual o menor a 9 es 7.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">Elemento igual o menor a 9: 7
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<p>El método <code>floor?(e)</code> es útil para encontrar el primer elemento igual o menor al valor especificado en el conjunto.</p>
<h2 is-upgraded>Nota adicional:</h2>
<p>Desde la perspectiva de la estructura del árbol subyacente en un TreeSet, el método <code>floor?(e)</code> busca el nodo más bajo en el árbol que sea igual o menor al valor especificado (e).</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
subSet(fromElement, toElement)" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
        treeSet.add(3);
        treeSet.add(6);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>subSet(fromElement, toElement)</code></h3>
<pre><code language="language-java" class="language-java">// Obtener un subconjunto desde el elemento de inicio hasta el elemento final (exclusivo)
TreeSet&lt;Integer&gt; subSet = new TreeSet&lt;&gt;(treeSet.subSet(3, 6));

// Imprimir el subconjunto
System.out.println(&#34;Subconjunto desde el elemento 3 hasta el elemento 6 (exclusivo): &#34; + subSet);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>subSet(fromElement, toElement)</code> devuelve un subconjunto del conjunto original que contiene todos los elementos mayores o iguales al elemento de inicio (fromElement) y estrictamente menores que el elemento final (toElement). En este caso, dado que hemos agregado los números 5, 2, 8, 3 y 6, el subconjunto contendrá los elementos 3 y 5.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">Subconjunto desde el elemento 3 hasta el elemento 6 (exclusivo): [3, 5]
</code></pre>
<p>Demostración en un árbol de busqueda binaria</p>
<p class="image-container"><img alt="Tree 5, 2, 8, 3, 6" src="img/53efe71f7bb36803.png"></p>
<h2 is-upgraded>Conclusión:</h2>
<p>El método <code>subSet(fromElement, toElement)</code> es útil para obtener un subconjunto que abarca desde el elemento de inicio (inclusive) hasta el elemento final (exclusivo).</p>
<h2 is-upgraded>Nota adicional:</h2>
<p>Al emplear <code>subSet(fromElement, toElement)</code>, es crucial recordar que el elemento final (toElement) no se incluirá en el subconjunto resultante. Este método es efectivo cuando necesitas una porción específica del conjunto original, delimitada por dos valores</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
tailSet(fromElement)" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
        treeSet.add(3);
        treeSet.add(6);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>tailSet(fromElement)</code></h3>
<pre><code language="language-java" class="language-java">// Obtener un subconjunto desde el elemento especificado (inclusivo)
TreeSet&lt;Integer&gt; tailSet = new TreeSet&lt;&gt;(treeSet.tailSet(3));

// Imprimir el subconjunto
System.out.println(&#34;Subconjunto desde el elemento 3 (inclusivo): &#34; + tailSet);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>tailSet(fromElement)</code> devuelve un subconjunto del conjunto original que contiene todos los elementos mayores o iguales al elemento especificado (fromElement). En este caso, dado que hemos agregado los números 5, 2, 8, 3 y 6, el subconjunto contendrá los elementos 3, 5, 6 y 8.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">Subconjunto desde el elemento 3 (inclusivo): [3, 5, 6, 8]
</code></pre>
<p>Demostración en un árbol de busqueda binaria</p>
<p class="image-container"><img alt="Tree 5, 2, 8, 3, 6" src="img/c2dae44c69d78d8c.png"></p>
<h2 is-upgraded>Conclusión:</h2>
<p>El método <code>tailSet(fromElement)</code> es útil para obtener un subconjunto que contiene todos los elementos mayores o iguales al elemento especificado.</p>
<h2 is-upgraded>Nota adicional:</h2>
<ul>
<li>Al utilizar <code>tailSet(fromElement)</code>, es esencial recordar que el subconjunto devuelto incluirá el elemento especificado (fromElement). Este método es útil cuando necesitas todos los elementos mayores o iguales a un valor particular en el conjunto original.</li>
<li>Similar a <code>headSet(toElement)</code>, el subconjunto devuelto es una vista respaldada por el conjunto original. Cualquier cambio en el conjunto original se reflejará en el subconjunto y viceversa. Esta característica permite trabajar eficientemente con porciones específicas del conjunto sin duplicar datos.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
headSet(Object toElement)" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
        treeSet.add(3);
        treeSet.add(6);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>headSet(toElement)</code></h3>
<pre><code language="language-java" class="language-java">// Obtener un subconjunto hasta el elemento especificado
TreeSet&lt;Integer&gt; headSet = new TreeSet&lt;&gt;(treeSet.headSet(6));

// Imprimir el subconjunto
System.out.println(&#34;Subconjunto hasta el elemento 6: &#34; + headSet);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>headSet(toElement)</code> devuelve un subconjunto del conjunto original que contiene todos los elementos estrictamente menores que el elemento especificado (toElement). En este caso, dado que hemos agregado los números 5, 2, 8, 3 y 6, el subconjunto contendrá los elementos 2, 3 Y 5.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">Subconjunto hasta el elemento 6 (exclusivo): [2, 3, 5]
</code></pre>
<p>Demostración en un árbol de busqueda binaria</p>
<p class="image-container"><img alt="Tree 5, 2, 8, 3, 6" src="img/8b3e7d168acb25c5.png"></p>
<h2 is-upgraded>Conclusión:</h2>
<p>El método headSet(toElement) es útil para obtener un subconjunto que contiene todos los elementos estrictamente menores que el elemento especificado.</p>
<h2 is-upgraded>Nota adicional:</h2>
<p>El subconjunto devuelto es una vista respaldada por el conjunto original, por lo que cualquier cambio en el conjunto original se reflejará en el subconjunto y viceversa.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
higher(E e)" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(10);
        treeSet.add(5);
        treeSet.add(15);
        treeSet.add(7);
        treeSet.add(12);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>higher(E e)</code></h3>
<pre><code language="language-java" class="language-java">// Obtener el primer elemento estrictamente mayor al elemento especificado
Integer higherElement = treeSet.higher(9);

// Imprimir el elemento obtenido
System.out.println(&#34;Primer elemento estrictamente mayor a 9: &#34; + higherElement);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>higher(E e)</code> devuelve el primer elemento estrictamente mayor al elemento especificado (e). En este caso, dado que hemos agregado los números 10, 5, 15, 7 y 12, el primer elemento estrictamente mayor a 9 es 10.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">Primer elemento estrictamente mayor a 9: 10
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<p>El método <code>higher(e)</code> es útil para encontrar el primer elemento estrictamente mayor al valor especificado en el conjunto.</p>
<h2 is-upgraded>Nota adicional:</h2>
<ul>
<li>Si no hay un elemento estrictamente mayor al especificado, el método devuelve null.</li>
<li>Este método es eficiente en conjuntos ordenados, ya que aprovecha la estructura jerárquica del árbol para realizar búsquedas de manera eficaz.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
isEmpty()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h2 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h2>
<pre><code language="language-java" class="language-java">import java.util.*;
import java.util.TreeSet;

public class TreeSetDemo {
    public static void main(String args[])
    {
        // Creating an empty HashSet
        TreeSet&lt;String&gt; tree = new TreeSet&lt;String&gt;();

        // Use add() method to add elements into the Set
        tree.add(&#34;Welcome&#34;);
        tree.add(&#34;To&#34;);
        tree.add(&#34;Geeks&#34;);
        tree.add(&#34;4&#34;);
        tree.add(&#34;Geeks&#34;);
        tree.add(&#34;TreeSet&#34;);

        // Displaying the TreeSet
        System.out.println(&#34;TreeSet: &#34; + tree);
</code></pre>
<h3 is-upgraded>Paso 2:Verificación si el conjunto está vacío</h3>
<pre><code language="language-java" class="language-java"> // Check for the empty set
        System.out.println(&#34;Is the set empty? &#34; + tree.isEmpty());
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>se utiliza para comprobar y verificar si un TreeSet está vacío o no. Devuelve True si el TreeSet está vacío, de lo contrario devuelve False.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">TreeSet: [4, Geeks, To, TreeSet, Welcome]
Is the set empty? false
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<p>-Método isEmpty en un TreeSet es que proporciona una forma conveniente de verificar si el conjunto está vacío o no. El método devuelve true si el conjunto no contiene elementos y false si tiene al menos un elemento.</p>
<h2 is-upgraded>Demostración en un árbol de busqueda binaria:</h2>
<p>La operación isEmpty() simplemente verificará si el TreeSet tiene al menos un elemento, es decir, si la raíz del árbol (el nodo &#34;Welcome&#34;) no es null.</p>
<p class="image-container"><img alt="TreeSet with clear" src="img/a73ca1b3805501be.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
iterator()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación de TreeSet y agregar elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;
import java.util.Iterator;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(&#34;C&#34;);
        treeSet.add(&#34;A&#34;);
        treeSet.add(&#34;B&#34;);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>iterator</code></h3>
<pre><code language="language-java" class="language-java">Iterator&lt;String&gt; iterator = treeSet.iterator();

// Iterar sobre los elementos e imprimirlos
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}

</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>iterator</code> devuelve un iterador que proporciona acceso a los elementos en el <code>TreeSet</code>. En este caso, al imprimir los elementos, se mostrarán en orden ascendente debido a la naturaleza del árbol de búsqueda binaria.</p>
<p>Resultado esperado:</p>
<pre><code>A
B
C
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>El método <code>iterator</code> proporciona un iterador que permite recorrer los elementos del <code>TreeSet</code> en orden ascendente.</li>
</ul>
<h2 is-upgraded>Nota adicional:</h2>
<ul>
<li>Puedes utilizar un bucle <code>for</code> mejorado (<code>foreach</code>) para simplificar el código al iterar sobre el <code>TreeSet</code>.</li>
</ul>
<pre><code language="language-java" class="language-java">for (String element : treeSet) {
    System.out.println(element);
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
last()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreesetExample {
    public static void main(String[] args) {
        // Crea a un TreeSet
        TreeSet&lt;Integer&gt; tree = new TreeSet&lt;Integer&gt;();

        // Agrega elementos
        tree.add(14);
        tree.add(8);
        tree.add(200);
        tree.add(48);
        tree.add(7);
        tree.add(124);
    }
}

</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>last</code></h3>
<pre><code language="language-java" class="language-java">   // Obtener el último elemento
    Integer lastElement = tree.last();

    // Imprimir el último elemento
    System.out.println(&#34;Último elemento: &#34; + lastElement);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>last()</code> devuelve el último elemento del conjunto sin eliminarlo. En este caso, el último elemento será 200.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">El último elemento es: 200
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<p>El método <code>last()</code> es útil para obtener el elemento más alto del conjunto sin eliminarlo.</p>
<h2 is-upgraded>Nota adicional:</h2>
<ul>
<li>Si el conjunto está vacío, <code>last()</code> lanzará una excepción NoSuchElementException, por lo que es importante asegurarse de que el conjunto contenga elementos antes de llamar a este método.</li>
<li>No hay impacto en la estructura del árbol ya que el método solo devuelve el último elemento sin realizar ninguna modificación en el conjunto original.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
lower(E e)" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h2 is-upgraded>Paso 1: Creación del Treeset y agrega elementos</h2>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;
public class GFG {
    public static void main(String args[])
    {
        TreeSet&lt;Integer&gt; tree = new TreeSet&lt;Integer&gt;();

        // Add elements to this TreeSet
        tree.add(10);
        tree.add(5);
        tree.add(8);
        tree.add(1);
        tree.add(11);
        tree.add(3);
</code></pre>
<h3 is-upgraded>Paso 2:Llamar al metodo tree.lower con la condicion deseada</h3>
<pre><code language="language-java" class="language-java"> System.out.println(tree.lower(15));
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>se utiliza para devolver el elemento más grande de este conjunto que es estrictamente menor que el elemento dado.</p>
<p>Resultado esperado:</p>
<pre><code language="language-java" class="language-java">11
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<p>-El propósito principal de lower es obtener el elemento más grande en el TreeSet que sea estrictamente menor que el valor proporcionado como argumento.</p>
<ul>
<li>el método tree.lower(elemento) en un TreeSet de Java devuelve el mayor elemento estrictamente menor que el valor especificado (elemento)</li>
</ul>
<h2 is-upgraded>Funcionamiento en un arbol de busqueda binaria:</h2>
<p>1.Comienzas en la raíz del árbol. 2.Comparas el elemento buscado con el elemento en el nodo actual. 3.Si son iguales, has encontrado el elemento y la búsqueda se completa. 4.Si el elemento buscado es menor que el elemento en el nodo actual, te mueves al subárbol izquierdo. 5.Si el elemento buscado es mayor que el elemento en el nodo actual, te mueves al subárbol derecho. 6.Se Repiten los pasos 2 y 3 hasta que encuentres el elemento buscado o llegues a un nodo que sea null, indicando que el elemento no está presente en el árbol.</p>
<p>Arbol Normal <img alt="TreeSet with clear" src="img/5452ad5e33e79603.png"> Despues de aplicar el metodo lower() <img alt="TreeSet with clear" src="img/97ac28ef48d1d590.png"></p>
<h2 is-upgraded>Nota adicional:</h2>
<p>-Si no existe ningún elemento de este tipo en esta colección TreeSet, este método devuelve un valor NULL -Solo se necesita un parámetro ele. Es el elemento a partir del cual se determina el mayor valor del conjunto que es estrictamente menor que este valor.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
pollFirst()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación de TreeSet y agregar elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>pollFirst()</code></h3>
<pre><code language="language-java" class="language-java">Integer firstElement = treeSet.pollFirst();

// Imprimir el primer elemento (o null si el conjunto estaba vacío)
System.out.println(&#34;Primer elemento: &#34; + firstElement);

</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método pollFirst devuelve y elimina el primer elemento del conjunto. En este caso, dado que hemos agregado los números 5, 2, y 8, el primer elemento será 2.</p>
<p>Resultado esperado:</p>
<pre><code>Primer elemento: 2
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>El método pollFirst es útil para obtener y eliminar el elemento más bajo del conjunto.</li>
<li>Devolverá null si el conjunto está vacío.</li>
</ul>
<h2 is-upgraded>Nota adicional:</h2>
<p>Debido a que el elemento a eliminar con <code>pollFirst</code> siempre será el primer elemento ordenado, por lo tanto, este elemento se encuentra en la hoja (leaf) del árbol. Al eliminar, no se necesitaria reorganizar todo el árbol, debido a que este elemento se encuentra sin &#34;hijos&#34; por así decirlo.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método 
pollLast()" duration="1">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación de TreeSet y agregar elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>pollLast()</code></h3>
<pre><code language="language-java" class="language-java">Integer lastElement = treeSet.pollLast();

// Imprimir el último elemento (o null si el conjunto estaba vacío)
System.out.println(&#34;Último elemento: &#34; + lastElement);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método <code>pollLast</code> devuelve y elimina el último elemento del conjunto. En este caso, dado que hemos agregado los números 5, 2, y 8, el último elemento será 8.</p>
<pre><code>Último elemento: 8
</code></pre>
<h2 is-upgraded>Conclusión:</h2>
<ul>
<li>El método pollLast es útil para obtener y eliminar el elemento más alto del conjunto.</li>
<li>Devolverá null si el conjunto está vacío.</li>
</ul>
<h2 is-upgraded>Nota adicional:</h2>
<p>Debido a que el elemento a eliminar con <code>pollLast</code> siempre será el último elemento ordenado, por lo tanto, este elemento se encuentra en la hoja (leaf) del árbol. Al eliminar, no se necesitaria reorganizar todo el árbol, debido a que este elemento se encuentra sin &#34;hijos&#34; por así decirlo.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Método remove(Object o)" duration="2">
        <h2 is-upgraded>Paso a paso:</h2>
<h3 is-upgraded>Paso 1: Creación de TreeSet y agregar elementos</h3>
<pre><code language="language-java" class="language-java">import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // Crear un TreeSet
        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();

        // Agregar elementos al TreeSet
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
    }
}
</code></pre>
<h3 is-upgraded>Paso 2: Uso del método <code>remove</code></h3>
<pre><code language="language-java" class="language-java">boolean removed = treeSet.remove(2);

// Imprimir si el elemento fue eliminado
System.out.println(&#34;¿Se eliminó el elemento? &#34; + removed);
</code></pre>
<h2 is-upgraded>Funcionamiento del método:</h2>
<p>El método remove elimina el elemento específico del conjunto. En este caso, al eliminar el número 2, el árbol se reorganizará adecuadamente.</p>
<p>Resultado esperado:</p>
<pre><code>¿Se eliminó el elemento? true
</code></pre>
<h3 is-upgraded>Estado del árbol después de <code>remove(2)</code></h3>
<p>Antes de la eliminación:</p>
<p class="image-container"><img alt="Tree initial with number" src="img/fa347dbf023f55a.png"></p>
<p>Después de la eliminación:</p>
<p class="image-container"><img alt="Tree remove" src="img/79561b6888d9374a.png"></p>
<h2 is-upgraded>Caso especial: elemento a eliminar como root</h2>
<p>Si el elemento a eliminar es la raíz, la reorganización del árbol puede afectar a sus subárboles. Por ejemplo, si eliminamos el 5:</p>
<p>Antes de la eliminación</p>
<p class="image-container"><img alt="Tree initial with number" src="img/fa347dbf023f55a.png"></p>
<p>Después de la eliminación</p>
<p class="image-container"><img alt="Tree initial with number" src="img/c4148d004d510b7d.png"></p>
<h2 is-upgraded>Conclusión:</h2>
<p>El método <code>remove</code> elimina el elemento específico del conjunto y reorganiza el árbol de búsqueda binaria en consecuencia.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
